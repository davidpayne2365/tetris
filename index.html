<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Mobile Tetris</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      height: 100vh;
      width: calc(100vh * (20 / 20)); /* keeps grid square */
      gap: 0;
      background: black;
    }
    .cell {
      aspect-ratio: 1/1;
      background-color: black;
    }
    .cell.active {
      background-color: white;
    }
    .cell.color-0 { background-color: cyan; }     /* I piece */
    .cell.color-1 { background-color: yellow; }   /* O piece */
    .cell.color-2 { background-color: purple; }   /* T piece */
    .cell.color-3 { background-color: blue; }     /* J piece */
    .cell.color-4 { background-color: orange; }   /* L piece */
    .cell.color-5 { background-color: green; }    /* S piece */
    .cell.color-6 { background-color: red; }      /* Z piece */
  </style>
</head>
<body>
  <div id="grid" class="grid"></div>

  <script>
    const gridEl = document.getElementById("grid");
    const cols = 20;
    const rows = 20;
    const grid = Array.from({ length: rows }, () => Array(cols).fill(0));
    const gridColors = Array.from({ length: rows }, () => Array(cols).fill(0));

    const shapes = [
      [[1, 1, 1, 1]],
      [[1, 1], [1, 1]],
      [[0, 1, 0], [1, 1, 1]],
      [[1, 0, 0], [1, 1, 1]],
      [[0, 0, 1], [1, 1, 1]],
      [[0, 1, 1], [1, 1, 0]],
      [[1, 1, 0], [0, 1, 1]]
    ];

    function randomShape() {
      const shapeIndex = Math.floor(Math.random() * shapes.length);
      const shape = shapes[shapeIndex];
      const shapeWidth = shape[0].length;
      const startX = Math.floor((cols - shapeWidth) / 2);
      return { x: startX, y: 0, shape, colorIndex: shapeIndex };
    }

    let current = randomShape();

    function shapeHeight(shape) {
      for (let i = shape.length - 1; i >= 0; i--) {
        if (shape[i].some(val => val)) return i + 1;
      }
      return shape.length;
    }

    function draw() {
      gridEl.innerHTML = '';
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (grid[y][x]) {
            cell.classList.add('active');
            cell.classList.add(`color-${gridColors[y][x]}`);
          } else if (
            current.shape.some((r, dy) =>
              r.some((v, dx) => v && current.y + dy === y && current.x + dx === x)
            )
          ) {
            cell.classList.add('active');
            cell.classList.add(`color-${current.colorIndex}`);
          }
          gridEl.appendChild(cell);
        }
      }
    }

    function canMove(shape, x, y) {
      return shape.every((row, dy) =>
        row.every((val, dx) => {
          if (!val) return true;
          const nx = x + dx;
          const ny = y + dy;
          return nx >= 0 && nx < cols && ny >= 0 && ny < rows && !grid[ny][nx];
        })
      );
    }

    function rotate(shape) {
      return shape[0].map((_, i) => shape.map(row => row[i])).reverse();
    }

    function tryRotate() {
      const rotated = rotate(current.shape);
      let offsetX = 0;
      while (!canMove(rotated, current.x + offsetX, current.y)) {
        offsetX++;
        if (offsetX > cols) return;
      }
      current.x += offsetX;
      current.shape = rotated;
    }

    function merge() {
      current.shape.forEach((row, dy) =>
        row.forEach((val, dx) => {
          if (
            val &&
            current.y + dy < rows &&
            current.x + dx >= 0 &&
            current.x + dx < cols
          ) {
            grid[current.y + dy][current.x + dx] = 1;
            gridColors[current.y + dy][current.x + dx] = current.colorIndex;
          }
        })
      );
    }

    function drop() {
      if (
        canMove(current.shape, current.x, current.y + 1) &&
        (current.y + shapeHeight(current.shape)) < rows
      ) {
        current.y++;
      } else {
        merge();
        current = randomShape();
        if (!canMove(current.shape, current.x, current.y)) {
          alert("Game Over");
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              grid[y][x] = 0;
              gridColors[y][x] = 0;
            }
          }
        }
      }
      draw();
    }

    setInterval(drop, 600);

    let startX = 0;
    let startTime = 0;
    let isTap = false;
    
    window.addEventListener("touchstart", e => {
      if (e.touches.length === 1) {
        startX = e.touches[0].clientX;
        startTime = Date.now();
        isTap = true;
      }
    });
    
    window.addEventListener("touchmove", e => {
      if (e.touches.length === 1) {
        const currentX = e.touches[0].clientX;
        const deltaX = currentX - startX;
        
        // If moved more than 10px, it's considered a swipe, not a tap
        if (Math.abs(deltaX) > 10) {
          isTap = false;
          
          // Move left or right based on swipe direction
          const dir = deltaX > 0 ? 1 : -1;
          if (canMove(current.shape, current.x + dir, current.y)) {
            current.x += dir;
            startX = currentX; // Update the start position for continuous movement
            draw();
          }
        }
      }
    });

    window.addEventListener("touchend", e => {
      const timeElapsed = Date.now() - startTime;
      
      // If it was a quick tap (less than 300ms) and didn't move much
      if (isTap && timeElapsed < 300) {
        tryRotate();
        draw();
      }
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") {
        if (canMove(current.shape, current.x - 1, current.y)) {
          current.x--;
        }
      } else if (e.key === "ArrowRight") {
        if (canMove(current.shape, current.x + 1, current.y)) {
          current.x++;
        }
      } else if (e.key === "ArrowUp") {
        tryRotate();
      } else if (e.key === "ArrowDown") {
        drop();
      }
      draw();
    });

    draw();
  </script>
</body>
</html>
