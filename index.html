<!DOCTYPE html>
<html>
<head>
    <title>Gesture-Controlled Rubik's Cube</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main variables
        let scene, camera, renderer;
        let cubeGroup, cubelets = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let startPoint = new THREE.Vector3();
        let movePoint = new THREE.Vector3();

        // State tracking
        let isRotating = false;
        let selectedCubelet = null;
        let selectedFace = null;
        let rotationAxis = null;
        let layerGroup = new THREE.Group();
        let touchStartX, touchStartY;
        let isCubeRotation = false;
        
        // Cube parameters
        const cubeSize = 3;
        const cubeSpacing = 1.05;
        
        // Colors for the cube faces
        const colors = {
            right: 0xff0000,  // red
            left: 0xffa500,   // orange
            top: 0xffffff,    // white
            bottom: 0xffff00, // yellow
            front: 0x00ff00,  // green
            back: 0x0000ff    // blue
        };
        
        // Initialize
        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 7);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf0f0f0);
            document.body.appendChild(renderer.domElement);
            
            // Create main cube group
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);
            
            // Create cube
            createCube();
            
            // Set initial rotation to show 3 sides
            cubeGroup.rotation.x = Math.PI / 6;
            cubeGroup.rotation.y = Math.PI / 4;
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onDocumentMouseDown);
            document.addEventListener('mousemove', onDocumentMouseMove);
            document.addEventListener('mouseup', onDocumentMouseUp);
            document.addEventListener('touchstart', onDocumentTouchStart, { passive: false });
            document.addEventListener('touchmove', onDocumentTouchMove, { passive: false });
            document.addEventListener('touchend', onDocumentTouchEnd);
            
            // Start animation loop
            animate();
        }
        
        // Create Rubik's Cube
        function createCube() {
            // Create all cubelets
            for (let x = 0; x < cubeSize; x++) {
                for (let y = 0; y < cubeSize; y++) {
                    for (let z = 0; z < cubeSize; z++) {
                        // Skip internal cubelet (for 3x3 cube)
                        if (x > 0 && x < cubeSize - 1 && 
                            y > 0 && y < cubeSize - 1 && 
                            z > 0 && z < cubeSize - 1) continue;
                        
                        // Create cubelet
                        const cubelet = createCubelet(x, y, z);
                        cubelet.userData = {
                            originalPosition: new THREE.Vector3(
                                (x - 1) * cubeSpacing,
                                (y - 1) * cubeSpacing,
                                (z - 1) * cubeSpacing
                            ),
                            currentPosition: new THREE.Vector3(x, y, z)
                        };
                        
                        // Position cubelet
                        cubelet.position.set(
                            (x - 1) * cubeSpacing,
                            (y - 1) * cubeSpacing,
                            (z - 1) * cubeSpacing
                        );
                        
                        cubelets.push(cubelet);
                        cubeGroup.add(cubelet);
                    }
                }
            }
        }
        
        // Create individual cubelet
        function createCubelet(x, y, z) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const materials = [];
            
            // Right face (red)
            materials.push(new THREE.MeshBasicMaterial({ 
                color: x === cubeSize - 1 ? colors.right : 0x111111 
            }));
            
            // Left face (orange)
            materials.push(new THREE.MeshBasicMaterial({ 
                color: x === 0 ? colors.left : 0x111111 
            }));
            
            // Top face (white)
            materials.push(new THREE.MeshBasicMaterial({ 
                color: y === cubeSize - 1 ? colors.top : 0x111111 
            }));
            
            // Bottom face (yellow)
            materials.push(new THREE.MeshBasicMaterial({ 
                color: y === 0 ? colors.bottom : 0x111111 
            }));
            
            // Front face (green)
            materials.push(new THREE.MeshBasicMaterial({ 
                color: z === cubeSize - 1 ? colors.front : 0x111111 
            }));
            
            // Back face (blue)
            materials.push(new THREE.MeshBasicMaterial({ 
                color: z === 0 ? colors.back : 0x111111 
            }));
            
            return new THREE.Mesh(geometry, materials);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Mouse down handler
        function onDocumentMouseDown(event) {
            event.preventDefault();
            
            // Calculate mouse position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Check for intersection
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubelets);
            
            if (intersects.length > 0) {
                // Store start position for dragging
                touchStartX = event.clientX;
                touchStartY = event.clientY;
                
                // Get the cubelet and face index
                selectedCubelet = intersects[0].object;
                selectedFace = Math.floor(intersects[0].faceIndex / 2); // Integer division
                
                // Store the intersection point in world coordinates
                startPoint = intersects[0].point.clone();
                
                // Record that we're trying to rotate a layer
                isRotating = true;
            } else {
                // Start cube rotation
                isCubeRotation = true;
                touchStartX = event.clientX;
                touchStartY = event.clientY;
            }
        }
        
        // Mouse move handler
        function onDocumentMouseMove(event) {
            event.preventDefault();
            
            if (isCubeRotation) {
                // Rotate the entire cube
                const deltaX = (event.clientX - touchStartX) * 0.01;
                const deltaY = (event.clientY - touchStartY) * 0.01;
                
                cubeGroup.rotation.y += deltaX;
                cubeGroup.rotation.x += deltaY;
                
                touchStartX = event.clientX;
                touchStartY = event.clientY;
                return;
            }
            
            // If we're not trying to rotate a layer, exit
            if (!isRotating || !selectedCubelet) return;
            
            // Calculate the current mouse position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the ray
            raycaster.setFromCamera(mouse, camera);
            
            // Get the plane perpendicular to the camera to determine drag direction
            const planeNormal = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);
            const plane = new THREE.Plane(planeNormal, 0);
            
            // Calculate the current point in 3D space
            const currentPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, currentPoint);
            
            // Calculate the movement from start point
            const moveVector = new THREE.Vector3().subVectors(currentPoint, startPoint);
            
            // If movement is significant, determine rotation
            if (moveVector.length() > 0.5) {
                // Determine rotation axis based on the face and movement
                determineRotationAxis(selectedFace, moveVector);
                
                // If rotation axis is determined, perform the rotation
                if (rotationAxis) {
                    // Find all cubelets in this layer
                    const layerCubelets = findLayerCubelets(selectedCubelet, rotationAxis);
                    
                    // Perform the rotation (90 degrees)
                    rotateLayer(layerCubelets, rotationAxis, Math.PI / 2);
                    
                    // Reset for next rotation
                    isRotating = false;
                    selectedCubelet = null;
                    selectedFace = null;
                    rotationAxis = null;
                }
            }
        }
        
        // Mouse up handler
        function onDocumentMouseUp(event) {
            isRotating = false;
            isCubeRotation = false;
            selectedCubelet = null;
            selectedFace = null;
        }
        
        // Touch start handler
        function onDocumentTouchStart(event) {
            event.preventDefault();
            
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                
                // Calculate touch position
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                // Check for intersection
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubelets);
                
                if (intersects.length > 0) {
                    // Store start position for dragging
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    
                    // Get the cubelet and face index
                    selectedCubelet = intersects[0].object;
                    selectedFace = Math.floor(intersects[0].faceIndex / 2); // Integer division
                    
                    // Store the intersection point in world coordinates
                    startPoint = intersects[0].point.clone();
                    
                    // Record that we're trying to rotate a layer
                    isRotating = true;
                } else {
                    // Start cube rotation
                    isCubeRotation = true;
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }
            }
        }
        
        // Touch move handler
        function onDocumentTouchMove(event) {
            event.preventDefault();
            
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                
                if (isCubeRotation) {
                    // Rotate the entire cube
                    const deltaX = (touch.clientX - touchStartX) * 0.01;
                    const deltaY = (touch.clientY - touchStartY) * 0.01;
                    
                    cubeGroup.rotation.y += deltaX;
                    cubeGroup.rotation.x += deltaY;
                    
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    return;
                }
                
                // If we're not trying to rotate a layer, exit
                if (!isRotating || !selectedCubelet) return;
                
                // Calculate the current touch position
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                // Update the ray
                raycaster.setFromCamera(mouse, camera);
                
                // Get the plane perpendicular to the camera to determine drag direction
                const planeNormal = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);
                const plane = new THREE.Plane(planeNormal, 0);
                
                // Calculate the current point in 3D space
                const currentPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, currentPoint);
                
                // Calculate the movement from start point
                const moveVector = new THREE.Vector3().subVectors(currentPoint, startPoint);
                
                // If movement is significant, determine rotation
                if (moveVector.length() > 0.3) { // Lower threshold for touch
                    // Determine rotation axis based on the face and movement
                    determineRotationAxis(selectedFace, moveVector);
                    
                    // If rotation axis is determined, perform the rotation
                    if (rotationAxis) {
                        // Find all cubelets in this layer
                        const layerCubelets = findLayerCubelets(selectedCubelet, rotationAxis);
                        
                        // Perform the rotation (90 degrees)
                        rotateLayer(layerCubelets, rotationAxis, Math.PI / 2);
                        
                        // Reset for next rotation
                        isRotating = false;
                        selectedCubelet = null;
                        selectedFace = null;
                        rotationAxis = null;
                    }
                }
            }
        }
        
        // Touch end handler
        function onDocumentTouchEnd(event) {
            isRotating = false;
            isCubeRotation = false;
            selectedCubelet = null;
            selectedFace = null;
        }
        
        // Determine rotation axis based on selected face and movement
        function determineRotationAxis(faceIndex, moveVector) {
            // Convert movement to cube local coordinates
            const localMoveVector = moveVector.clone().applyQuaternion(cubeGroup.quaternion.clone().invert());
            
            // Get the normal of the selected face
            const faceNormal = getFaceNormal(faceIndex);
            
            // Face normals:
            // 0: +X (right), 1: -X (left)
            // 2: +Y (top), 3: -Y (bottom)
            // 4: +Z (front), 5: -Z (back)
            
            // Determine the primary movement direction
            const absX = Math.abs(localMoveVector.x);
            const absY = Math.abs(localMoveVector.y);
            const absZ = Math.abs(localMoveVector.z);
            
            let primaryDirection;
            if (absX > absY && absX > absZ) {
                primaryDirection = new THREE.Vector3(Math.sign(localMoveVector.x), 0, 0);
            } else if (absY > absX && absY > absZ) {
                primaryDirection = new THREE.Vector3(0, Math.sign(localMoveVector.y), 0);
            } else {
                primaryDirection = new THREE.Vector3(0, 0, Math.sign(localMoveVector.z));
            }
            
            // The rotation axis is the cross product of the face normal and the primary movement direction
            const axis = new THREE.Vector3().crossVectors(faceNormal, primaryDirection);
            
            // Check if axis is non-zero
            if (axis.lengthSq() > 0.1) {
                // Normalize the axis to get a unit vector
                axis.normalize();
                
                // Find the dominant axis
                const axisMaxComponent = Math.max(Math.abs(axis.x), Math.abs(axis.y), Math.abs(axis.z));
                
                if (Math.abs(axis.x) === axisMaxComponent) {
                    rotationAxis = 'x';
                } else if (Math.abs(axis.y) === axisMaxComponent) {
                    rotationAxis = 'y';
                } else {
                    rotationAxis = 'z';
                }
            }
        }
        
        // Get the normal vector for a given face index
        function getFaceNormal(faceIndex) {
            switch (faceIndex) {
                case 0: return new THREE.Vector3(1, 0, 0);  // +X (right)
                case 1: return new THREE.Vector3(-1, 0, 0); // -X (left)
                case 2: return new THREE.Vector3(0, 1, 0);  // +Y (top)
                case 3: return new THREE.Vector3(0, -1, 0); // -Y (bottom)
                case 4: return new THREE.Vector3(0, 0, 1);  // +Z (front)
                case 5: return new THREE.Vector3(0, 0, -1); // -Z (back)
                default: return new THREE.Vector3(0, 0, 0);
            }
        }
        
        // Find all cubelets in a layer
        function findLayerCubelets(selectedCubelet, axis) {
            const position = selectedCubelet.position.clone();
            const threshold = 0.1;
            
            // Find all cubelets that share the same coordinate on the specified axis
            return cubelets.filter(cubelet => {
                switch (axis) {
                    case 'x':
                        return Math.abs(cubelet.position.x - position.x) < threshold;
                    case 'y':
                        return Math.abs(cubelet.position.y - position.y) < threshold;
                    case 'z':
                        return Math.abs(cubelet.position.z - position.z) < threshold;
                }
            });
        }
        
        // Rotate a layer around an axis
        function rotateLayer(layerCubelets, axis, angle) {
            // Create temporary rotation group
            layerGroup = new THREE.Group();
            scene.add(layerGroup);
            
            // Add all cubelets to the temporary group
            layerCubelets.forEach(cubelet => {
                // Store the original world position and quaternion
                const worldPos = new THREE.Vector3();
                const worldQuaternion = new THREE.Quaternion();
                cubelet.getWorldPosition(worldPos);
                cubelet.getWorldQuaternion(worldQuaternion);
                
                // Remove from the main cube group
                cubeGroup.remove(cubelet);
                
                // Add to the temporary rotation group
                layerGroup.add(cubelet);
                
                // Maintain world position
                cubelet.position.copy(worldPos);
                cubelet.position.sub(layerGroup.position);
                cubelet.quaternion.copy(worldQuaternion);
            });
            
            // Apply the rotation to the group
            switch (axis) {
                case 'x':
                    layerGroup.rotateX(angle);
                    break;
                case 'y':
                    layerGroup.rotateY(angle);
                    break;
                case 'z':
                    layerGroup.rotateZ(angle);
                    break;
            }
            
            // Update matrixWorld
            layerGroup.updateMatrixWorld(true);
            
            // Move all cubelets back to the main cube group
            while (layerGroup.children.length > 0) {
                const cubelet = layerGroup.children[0];
                
                // Get the new world position and quaternion
                const worldPos = new THREE.Vector3();
                const worldQuaternion = new THREE.Quaternion();
                cubelet.getWorldPosition(worldPos);
                cubelet.getWorldQuaternion(worldQuaternion);
                
                // Remove from the temporary group
                layerGroup.remove(cubelet);
                
                // Add back to the main cube group
                cubeGroup.add(cubelet);
                
                // Set the local position and rotation
                cubelet.position.copy(worldPos);
                cubelet.position.sub(cubeGroup.position);
                cubelet.quaternion.copy(worldQuaternion);
            }
            
            // Remove the temporary group
            scene.remove(layerGroup);
        }
        
        // Initialize when window loads
        window.onload = init;
    </script>
</body>
</html>
