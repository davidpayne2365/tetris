<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Mobile Tetris</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #111;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(20, 1fr);
      height: 100vh;
      width: calc(100vh * (20 / 20));
      gap: 0;
      background: black;
    }
    .cell {
      aspect-ratio: 1/1;
      background-color: black;
    }
    .cell.active {
      background-color: white;
    }
  </style>
</head>
<body>
  <div id="grid" class="grid"></div>

  <script>
    const gridEl = document.getElementById("grid");
    const cols = 20;
    const rows = 20;
    const grid = Array.from({ length: rows }, () => Array(cols).fill(0));

    const shapes = [
      { shape: [[1, 1, 1, 1]], color: 'cyan' },             // I
      { shape: [[1, 1], [1, 1]], color: 'yellow' },          // O
      { shape: [[0, 1, 0], [1, 1, 1]], color: 'purple' },    // T
      { shape: [[1, 0, 0], [1, 1, 1]], color: 'blue' },      // J
      { shape: [[0, 0, 1], [1, 1, 1]], color: 'orange' },    // L
      { shape: [[0, 1, 1], [1, 1, 0]], color: 'green' },     // S
      { shape: [[1, 1, 0], [0, 1, 1]], color: 'red' }        // Z
    ];

    function randomShape() {
      const { shape, color } = shapes[Math.floor(Math.random() * shapes.length)];
      const shapeWidth = shape[0].length;
      const startX = Math.floor((cols - shapeWidth) / 2);
      return { x: startX, y: 0, shape, color };
    }

    let current = randomShape();

    function shapeHeight(shape) {
      for (let i = shape.length - 1; i >= 0; i--) {
        if (shape[i].some(val => val)) return i + 1;
      }
      return shape.length;
    }

    function draw() {
      gridEl.innerHTML = '';
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';

          if (grid[y][x]) {
            cell.style.backgroundColor = grid[y][x];
          } else {
            let colored = false;
            current.shape.forEach((row, dy) =>
              row.forEach((v, dx) => {
                if (
                  v &&
                  current.y + dy === y &&
                  current.x + dx === x
                ) {
                  cell.style.backgroundColor = current.color;
                  colored = true;
                }
              })
            );
          }

          gridEl.appendChild(cell);
        }
      }
    }

    function canMove(shape, x, y) {
      return shape.every((row, dy) =>
        row.every((val, dx) => {
          if (!val) return true;
          const nx = x + dx;
          const ny = y + dy;
          return nx >= 0 && nx < cols && ny >= 0 && ny < rows && !grid[ny][nx];
        })
      );
    }

    function rotate(shape) {
      return shape[0].map((_, i) => shape.map(row => row[i])).reverse();
    }

    function tryRotate() {
      const rotated = rotate(current.shape);
      let offsetX = 0;
      while (!canMove(rotated, current.x + offsetX, current.y)) {
        offsetX++;
        if (offsetX > cols) return;
      }
      current.x += offsetX;
      current.shape = rotated;
    }

    function merge() {
      current.shape.forEach((row, dy) =>
        row.forEach((val, dx) => {
          if (
            val &&
            current.y + dy < rows &&
            current.x + dx >= 0 &&
            current.x + dx < cols
          ) {
            grid[current.y + dy][current.x + dx] = current.color;
          }
        })
      );
    }

    function drop() {
      if (
        canMove(current.shape, current.x, current.y + 1) &&
        (current.y + shapeHeight(current.shape)) < rows
      ) {
        current.y++;
      } else {
        merge();
        current = randomShape();
        if (!canMove(current.shape, current.x, current.y)) {
          alert("Game Over");
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              grid[y][x] = 0;
            }
          }
        }
      }
      draw();
    }

    setInterval(drop, 600);

    let startX = 0;
    window.addEventListener("touchstart", e => {
      if (e.touches.length === 1) {
        startX = e.touches[0].clientX;
      }
    });

    window.addEventListener("touchend", e => {
      const endX = e.changedTouches[0].clientX;
      const deltaX = endX - startX;

      if (Math.abs(deltaX) < 10) {
        tryRotate();
      } else {
        const dir = deltaX > 0 ? 1 : -1;
        if (canMove(current.shape, current.x + dir, current.y)) {
          current.x += dir;
        }
      }
      draw();
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") {
        if (canMove(current.shape, current.x - 1, current.y)) {
          current.x--;
        }
      } else if (e.key === "ArrowRight") {
        if (canMove(current.shape, current.x + 1, current.y)) {
          current.x++;
        }
      } else if (e.key === "ArrowUp") {
        tryRotate();
      } else if (e.key === "ArrowDown") {
        drop();
      }
      draw();
    });

    draw();
  </script>
</body>
</html>
